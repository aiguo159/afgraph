<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>afgraph: afgraph: A Framework for Graph Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">afgraph</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('index.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">afgraph: A Framework for Graph Algorithms </div>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="intro"></a>
Introduction</h2>
<p>My Ph.D. research (1997-2001) was mostly on graph algorithm, in some sense. Most of my work was to come out with some algorithms to solve some particular problems and wrote some code to simulate the algorithms (in a particular computer network setting) and compare them with some other algorithms on certain metrics. Most of the code that I wrote were specific to certain problems and it is mostly useless to others; the problems that I worked on were no longer relevant anyway. However, a small core portion of the code is generic in nature -- it served as the basis for me to write implementations of various graph-related algorithms. A few months after I graduated, I packaged that portion of code and gave it to a friend of mine upon his request. I have never asked him if he found the code useful or not. However, it is always my belief that it can be useful to certain people who happen to work in this domain. So I decided to release this code to the public, a good 11-years after my graduation. Better late than never.</p>
<p>The code has been basically the same as 11 years ago, except some small updates that have been made to make it compile with newer versions of compilers -- C++ the language and compilers have evolved quite a bit over the time. As of now (March 2012), it compiles with the following: g++ 4.6.1 on Linux, g++ 4.3.4 under Cygwin on Windows, Microsoft Visual C++ 2010 (Express Edition). Because of the age of the code, it may look a little old-fashioned or out of date, or may not. Either way, I hope that some people will find it useful.</p>
<h3><a class="anchor" id="sub_inside"></a>
What's Inside</h3>
<p>Under the top directory, you will find the following:</p>
<div class="fragment"><pre class="fragment">
docs/: documentation source
docs-gen/: generated documentations, in pdf, chm, qch format
    html/: documentations in html
include/: header files
    afl/: some template utilties
    afgraph/: the main stuff
    news/: a couple of files for an unfinished network simulator
    research/: code for research purpose (e.g., code to import "asconnect" file,
        may be useful to others)
net_topology/: data files of actual network topology
    mbone/: (very old) mbone topology
test/: code for sanity test
    afgraph/
    news/
    research/
src/: .cpp file, just one
    news/
examples/: examples, juse one for now.

</pre></div><h3><a class="anchor" id="sub_docs"></a>
Documentations</h3>
<p>Code has been documented extensively with doxygen tags. Documentations in pdf, chm, qch and html format are generated from the source and included in this release. You may run doxygen to re-generate them if you add/modify source code documentations: go to docs/, run "doxygen afgraphdoc_doxygen-chm.conf" and "doxygen afgraphdoc_doxygen-html.conf".</p>
<p>You need the following tools to produce documentations other than html: (1) pdflatex to generate the pdf version (go to docs-gen/latex, run "pdflatex" twice); (2) Microsoft HTML Help Workshop to produce chm file (open docs-gen/chm/index.hhp in HTML Help Workshop); (3) qhelpgenerator from Qt SDK to create qch file (edit docs/afgraphdoc_doxygen-chm.conf to point to where qhelpgenerator is installed), which can be opened with Qt assistant.</p>
<h2><a class="anchor" id="start"></a>
Get Started</h2>
<h3><a class="anchor" id="sub_example"></a>
An Example</h3>
<p>Under examples/, you will find one example: e_graph.cpp. This file demonstrates how to create a graph and run a couple of algorithms included in this package.</p>
<div class="fragment"><pre class="fragment">

// mem_fun should give us this; but couldn't get it pass the compiler.
// Too much templating, I guess.
char get_vertex_d( const CiVertex&lt;char, int&gt; &amp;v )
{
    return v.vertex_d();
}

int main()
{
    // Create a graph with char vertext type (i.e., each vertex is identified
    // by a char) and integer edge type (i.e., each edge has an integer value).
    // It has 10 vertices and 'z' will not be used as a vertex id.
    // An unused vertex id is needed to populate empty spots (if any) in the
    // vertex array.
    CGraph&lt;char, int&gt; gra( 6, 'z' );

    // insert all the nodes; their IDs are ['a'..'f'].
    for( int i=0; i&lt;6; ++i ){
        gra.insert_v( i+97 ); // 97 is ASCII 'a'
    }

    // Now insert all the edges. It is a non-directed graph, each edge is
    // represented by 2 directed edges.
    gra.insert_2e( 'a', 'b', 3 ); gra.insert_2e( 'a', 'd', 4 );
    gra.insert_2e( 'b', 'c', 2 ); gra.insert_2e( 'b', 'd', 3 );
    gra.insert_2e( 'c', 'f', 6 ); gra.insert_2e( 'd', 'e', 2 );
    gra.insert_2e( 'e', 'f', 3 );

    // print out the graph; note the difference between vertex ID and vertex index.
    std::cout &lt;&lt; "graph now: " &lt;&lt; std::endl &lt;&lt; gra &lt;&lt; std::endl;

    // let's check if this graph is connected.
    std::cout &lt;&lt; "connected?: " &lt;&lt; (is_connected( gra )?"yes":"no") &lt;&lt; std::endl;

    // All graph algorithms operate on vertex indices; let's find the index
    // for node 'c' and 'e'.
    int idxC = gra.find_index( 'c' );
    int idxE = gra.find_index( 'e' );
    cout &lt;&lt; "node 'c' is at "&lt;&lt; idxC &lt;&lt; ", and node 'e' is at " &lt;&lt; idxE &lt;&lt; endl;

    /* Run dijkstra algorithm to find the shorted path from 'c' to 'e', using
    each edge's integer value as the weight -- so we pass functor
    afl::pointer2value&lt;int&gt;() for that purpose. The edge weight function passed
    to dijkstra_t() will be called with an pointer to an edge.
    */
    CPath lp;
    cout &lt;&lt; "shortest path by edge weight from node 'c' to 'e' result: "
         &lt;&lt; dijkstra_t&lt;CGraph&lt;char, int&gt; &gt;(
             gra, idxC, idxE, afl::pointer2value&lt;int&gt;(), 1000, lp )
         &lt;&lt; endl &lt;&lt; "path found (by indices): " &lt;&lt; lp &lt;&lt; endl;
    cout &lt;&lt; "path found (by ID): " ;
    lp.output( cout, gra, get_vertex_d ) &lt;&lt; endl;
    //lp.output( cout, gra, mem_fun( &amp;ciVertex_t::vertex_d ) ) &lt;&lt; endl;

    /* Run dijkstra algorithm to find the shorted path from 'c' to 'e', each
    edge having weight 1 -- equivalent to finding minimum hop-count path.
    */
    CPath lp2;
    cout &lt;&lt; "shortest path by hop-count from node 'c' to 'e' result: "
         &lt;&lt; dijkstra_t&lt;CGraph&lt;char, int&gt; &gt;(
             gra, idxC, idxE, afl::runit_p&lt;int&gt;(), 1000, lp2 )
         &lt;&lt; endl &lt;&lt; "path found (by indices): " &lt;&lt; lp2 &lt;&lt; endl;
    cout &lt;&lt; "path found (by ID): " ;
    lp2.output( cout, gra, get_vertex_d ) &lt;&lt; endl;

    return 0;
}

</pre></div><p>Under test/afgraph, there are some test code that I used for sanity test -- they can serve as examples of how to use the framework. To learn how to use the framework to implement your own graph algorithms, you may check out the following files under include/afgraph as examples: <a class="el" href="shortest__path_8h.html">shortest_path.h</a>, <a class="el" href="graph__alg_8h.html">graph_alg.h</a>, <a class="el" href="kthsp_8h.html">kthsp.h</a>, <a class="el" href="tree__alg_8h.html">tree_alg.h</a>.</p>
<h3><a class="anchor" id="sub_cmp_run"></a>
Compile and Run</h3>
<p>For the example and test programs, a build tool called Scons is used -- instead of Makefile, the build script file is named Scontruct. Compared with conventional make, Scons has some advantages; for small profject, it is fairly easy and straight-forward. If you don't have Scons installed already on your system, you need to install it.</p>
<p>On a terminal under Linux/BSD/*nix/Windows, go to examples/, type the command "scons" or "scons.bat", it will build the example program with the output under examples/output_opt/; type the command "./output_opt/e_graph" to run it ("./output_opt/e_graph.exe" under Windows). To build a debug version of the program with debug symbols, do "scons debug=1" and the output will be under output_dbg/.</p>
<p>Go to test/afgraph, do "scons" or "scons debug=1" to build all the test programs.</p>
<p>Note 1: some test programs use some data files which are located in the same directory as the source file; e.g., under test/afgraph/, t_graph_input.cpp uses gra1.vve and a few others. You need to run the compiled program from the directory where the data files are located so the test program can find them; e.g., under test/afgraph/, you run "./output_opt/t_graph_input".</p>
<p>Note 2: "-Wall" is enabled in Sconstruct files. With gcc, all code compiles without any warning. However, with MS Visual C++, it generates a lot of warnings which don't really have anything to do with the code here. You may disable "-Wall" on for Visual C++.</p>
<h2><a class="anchor" id="design"></a>
Concept and Design</h2>
<p>The framework implements an adjacency-list representation of graphs: vertices are stored as an vecrtor with each elements accessible via indices, and all edges of a vertex is stored in a list accessible via iterators. Vertices can be accessed via iterators as well. Each vertex should have some uniquely identifiable data (identifier), while each edge may have some arbitrary data.</p>
<p>An algorithm would use indices or iterators to access the vertices and use iterators to access the edges and operate on them. For an algorithm that takes a vertex and vertices as input, usually the input can ben in the form of index or indices -- there is really no need to use vertex "identifiers" as input since index of a vertex can be found from a vertex identifier.</p>
<p>The implementation supports (fairly) efficient insertion/deletion of vertices. A few helpers funtions are there to facilitate that: (1) because deletion can leave hole in the vertex vector, function is_in_use() can be used to test if the given index has a valid vertex or just empty; (2) vertex vector will dynamically grow when new ones are inserted, controlled by a growth factor. (3) vertex vector doesn't shrink by itself -- call function pack() to remove all holes in the vertex vector and store all vertices consecutively and thus shrink the vertex vector; (4) if you know the graph size beforehand, you can use reserve() to reserve the vertex vector.</p>
<h3><a class="anchor" id="interface"></a>
Framework as An Interface</h3>
<p>Adjacency-list is one possible representation of graphs, and implementation here is one possible implementation. For some algorithms, maybe a different representation or implementation works better. Algorithms implemented based on the framework is "portable" in the sense that you can easily use a different graph implementation without needing to re-write the algorithms as long as the new implementation provides the same interface as specified in <a class="el" href="graph__intf_8h.html">graph_intf.h</a> -- which basically specifies index and iterator access to vertices and iterator access to edges.</p>
<h2><a class="anchor" id="interest"></a>
Stuff of Interest</h2>
<p><a class="el" href="export__gdl_8h.html">export_gdl.h</a>: utility to export gdl (graph description language) file that can be imported to graph visualization tools to visualize graphs.</p>
<p><a class="el" href="graph__gen_8h.html">graph_gen.h</a>: includes a graph generator based on B.M. Waxman's method; can be used to generate graphs to test graph algorithms.</p>
<p><a class="el" href="import__gitalt_8h.html">import_gitalt.h</a>: utility to import graph from the alt file by GeorgiaTech graph generator.</p>
<p><a class="el" href="import__asconnect_8h.html">import_asconnect.h</a>: utility to import graph from an "asconnect" files. Asconnect file is a list of AS's (Autonomous System in BGP routing) and their interconnections, *used to* be available for download from: <a href="http://www.antc.uoregon.edu/route-views/;">http://www.antc.uoregon.edu/route-views/;</a> however, when I checked recently, I didn't see them there, nor could I find them at <a href="http://www.routeviews.org/.">http://www.routeviews.org/.</a> You may need to contact them to see if those files are still available. </p>
</div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<center>afgraph - A Framework for Graph Algorithms</center>
