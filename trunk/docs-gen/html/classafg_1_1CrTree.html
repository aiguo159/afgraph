<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>afgraph: afg::CrTree&lt; VDT, EDT, f_eqv &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">afgraph</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classafg_1_1CrTree.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">afg::CrTree&lt; VDT, EDT, f_eqv &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__rtree.html">A Rooted Tree Structure</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="afg::CrTree" --><!-- doxytag: inherits="CGraph&lt; VDT, EDT, f_eqv &gt;" -->
<p><code>#include &lt;<a class="el" href="rtree_8h_source.html">rtree.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for afg::CrTree&lt; VDT, EDT, f_eqv &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classafg_1_1CrTree__inherit__graph.png" border="0" usemap="#afg_1_1CrTree_3_01VDT_00_01EDT_00_01f__eqv_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="afg_1_1CrTree_3_01VDT_00_01EDT_00_01f__eqv_01_4_inherit__map" id="afg_1_1CrTree_3_01VDT_00_01EDT_00_01f__eqv_01_4_inherit__map">
<area shape="rect" id="node2" href="classafg_1_1CGraph.html" title="afg::CGraph\&lt; VDT, EDT, f_eqv \&gt;" alt="" coords="1008,5,1227,35"/><area shape="rect" id="node4" href="classafg_1_1IGraph.html" title="afg::IGraph\&lt; VDT, EDT, f_eqv, std::vector\&lt; CiVertex\&lt; VDT, EDT \&gt; \&gt;::iterator, std::vector\&lt; CiVertex\&lt; VDT, EDT \&gt; \&gt;::const_iterator, CiVertex\&lt; VDT, EDT \&gt; \&gt;" alt="" coords="5,5,960,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for afg::CrTree&lt; VDT, EDT, f_eqv &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classafg_1_1CrTree__coll__graph.png" border="0" usemap="#afg_1_1CrTree_3_01VDT_00_01EDT_00_01f__eqv_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="afg_1_1CrTree_3_01VDT_00_01EDT_00_01f__eqv_01_4_coll__map" id="afg_1_1CrTree_3_01VDT_00_01EDT_00_01f__eqv_01_4_coll__map">
<area shape="rect" id="node2" href="classafg_1_1CGraph.html" title="afg::CGraph\&lt; VDT, EDT, f_eqv \&gt;" alt="" coords="1384,33,1603,63"/><area shape="rect" id="node4" href="classafg_1_1IGraph.html" title="afg::IGraph\&lt; VDT, EDT, f_eqv, std::vector\&lt; CiVertex\&lt; VDT, EDT \&gt; \&gt;::iterator, std::vector\&lt; CiVertex\&lt; VDT, EDT \&gt; \&gt;::const_iterator, CiVertex\&lt; VDT, EDT \&gt; \&gt;" alt="" coords="315,8,1269,37"/><area shape="rect" id="node8" href="classafl_1_1sorted__list.html" title="afl::sorted_list\&lt; int \&gt;" alt="" coords="721,61,863,91"/><area shape="rect" id="node10" href="classstd_1_1list.html" title="std::list\&lt;int , std::allocator\&lt;int \&gt; \&gt;" alt="" coords="7,61,225,91"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classafg_1_1CrTree-members.html">List of all members.</a></p>
<h2><a name="pub-types"></a>
Public Types</h2>
<ul>
<li><a class="anchor" id="a5ff536833371215e6ecab873ea10efd1"></a><!-- doxytag: member="afg::CrTree::TT" ref="a5ff536833371215e6ecab873ea10efd1" args="" -->
typedef <a class="el" href="classafg_1_1CrTree.html">CrTree</a>&lt; <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a>, <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a>, f_eqv &gt; <a class="el" href="classafg_1_1CrTree.html#a5ff536833371215e6ecab873ea10efd1">TT</a>
<dl class="el"><dd class="mdescRight">tree type, this class itself <br/></dl><li><a class="anchor" id="af37477bf1cec0d431960c7591de18a69"></a><!-- doxytag: member="afg::CrTree::base_graph_t" ref="af37477bf1cec0d431960c7591de18a69" args="" -->
typedef <a class="el" href="classafg_1_1CGraph.html">CGraph</a>&lt; <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a>, <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a>, f_eqv &gt; <b>base_graph_t</b>
</ul>
<h2><a name="pub-methods"></a>
Public Member Functions</h2>
<ul>
<li><a class="anchor" id="a0ca45adf71f9fa1fe26600389d1437ae"></a><!-- doxytag: member="afg::CrTree::CrTree" ref="a0ca45adf71f9fa1fe26600389d1437ae" args="(int size=1, VDT v=VDT(), double dg=0.25, const f_eqv &amp;eqv=f_eqv())" -->
<a class="el" href="classafg_1_1CrTree.html#a0ca45adf71f9fa1fe26600389d1437ae">CrTree</a> (int size=1, <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a> v=<a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a>(), double dg=0.25, const f_eqv &amp;eqv=f_eqv())
<dl class="el"><dd class="mdescRight">constructor. <br/></dl><li><a class="anchor" id="a36e271479e65b655c774934be9145c03"></a><!-- doxytag: member="afg::CrTree::CrTree" ref="a36e271479e65b655c774934be9145c03" args="(const TT &amp;rhs)" -->
<b>CrTree</b> (const <a class="el" href="classafg_1_1CrTree.html">TT</a> &amp;rhs)
<li><a class="anchor" id="a90f662943b6a64efac2a82b1d6330504"></a><!-- doxytag: member="afg::CrTree::operator=" ref="a90f662943b6a64efac2a82b1d6330504" args="(const TT &amp;rhs)" -->
const <a class="el" href="classafg_1_1CrTree.html">TT</a> &amp; <b>operator=</b> (const <a class="el" href="classafg_1_1CrTree.html">TT</a> &amp;rhs)
<li><a class="anchor" id="a31bce53be2071eb620758dec594d88f4"></a><!-- doxytag: member="afg::CrTree::copy_vertices" ref="a31bce53be2071eb620758dec594d88f4" args="(const base_graph_t &amp;gra)" -->
virtual void <a class="el" href="classafg_1_1CrTree.html#a31bce53be2071eb620758dec594d88f4">copy_vertices</a> (const <a class="el" href="classafg_1_1CGraph.html">base_graph_t</a> &amp;gra)
<dl class="el"><dd class="mdescRight">copy all vertices from a graph <br/></dl><li><a class="anchor" id="aab1ee7a4c488f1297f508566bf2956e6"></a><!-- doxytag: member="afg::CrTree::parent" ref="aab1ee7a4c488f1297f508566bf2956e6" args="(const VDT &amp;v) const " -->
int <a class="el" href="classafg_1_1CrTree.html#aab1ee7a4c488f1297f508566bf2956e6">parent</a> (const <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a> &amp;v) const 
<dl class="el"><dd class="mdescRight">return parent node of node v <br/></dl><li>int <a class="el" href="classafg_1_1CrTree.html#a1a346395262540eba806787f217f8431">parent_byi</a> (int i) const   throw ( std::out_of_range )
<li><a class="anchor" id="a3fa49da7457a0b26abb41e19f76c30e5"></a><!-- doxytag: member="afg::CrTree::root" ref="a3fa49da7457a0b26abb41e19f76c30e5" args="(void) const " -->
int <a class="el" href="classafg_1_1CrTree.html#a3fa49da7457a0b26abb41e19f76c30e5">root</a> (void) const 
<dl class="el"><dd class="mdescRight">return the index of the root node <br/></dl><li><a class="anchor" id="a84d201907c41b6f46990b32e2cb38cfe"></a><!-- doxytag: member="afg::CrTree::root" ref="a84d201907c41b6f46990b32e2cb38cfe" args="(void)" -->
int &amp; <a class="el" href="classafg_1_1CrTree.html#a84d201907c41b6f46990b32e2cb38cfe">root</a> (void)
<dl class="el"><dd class="mdescRight">return the index of the root node, by reference <br/></dl><li><a class="anchor" id="ae1ea132b263c92116cd5e0c1a4f37bf3"></a><!-- doxytag: member="afg::CrTree::set_root" ref="ae1ea132b263c92116cd5e0c1a4f37bf3" args="(const VDT &amp;v)" -->
bool <a class="el" href="classafg_1_1CrTree.html#ae1ea132b263c92116cd5e0c1a4f37bf3">set_root</a> (const <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a> &amp;v)
<dl class="el"><dd class="mdescRight">set the root node <br/></dl><li><a class="anchor" id="a96162da2ac0f71be83aed38f41ec071b"></a><!-- doxytag: member="afg::CrTree::set_root_byi" ref="a96162da2ac0f71be83aed38f41ec071b" args="(int n)" -->
bool <a class="el" href="classafg_1_1CrTree.html#a96162da2ac0f71be83aed38f41ec071b">set_root_byi</a> (int n)
<dl class="el"><dd class="mdescRight">set the root node by index <br/></dl><li><a class="anchor" id="a1ffcbd5f97cfe355a1a0f2ef7a643523"></a><!-- doxytag: member="afg::CrTree::first_root" ref="a1ffcbd5f97cfe355a1a0f2ef7a643523" args="(void) const " -->
int <a class="el" href="classafg_1_1CrTree.html#a1ffcbd5f97cfe355a1a0f2ef7a643523">first_root</a> (void) const 
<dl class="el"><dd class="mdescRight">find the first node which doesn't have a parent <br/></dl><li><a class="anchor" id="a218a9637d985ef18ddbf7edcb672d19e"></a><!-- doxytag: member="afg::CrTree::is_member" ref="a218a9637d985ef18ddbf7edcb672d19e" args="(int i) const " -->
bool <b>is_member</b> (int i) const 
<li><a class="anchor" id="a1ddfc7cb05344e858198e05b4564e69b"></a><!-- doxytag: member="afg::CrTree::is_leaf" ref="a1ddfc7cb05344e858198e05b4564e69b" args="(int i) const " -->
bool <b>is_leaf</b> (int i) const 
<li><a class="anchor" id="a0ed8f0d7089096b589c374dee375581c"></a><!-- doxytag: member="afg::CrTree::output" ref="a0ed8f0d7089096b589c374dee375581c" args="(std::ostream &amp;os) const " -->
virtual std::ostream &amp; <a class="el" href="classafg_1_1CrTree.html#a0ed8f0d7089096b589c374dee375581c">output</a> (std::ostream &amp;os) const 
<dl class="el"><dd class="mdescRight">output graph to a stream <br/></dl><li>virtual void <a class="el" href="classafg_1_1CrTree.html#ad615d12d6b0cdc03744470e537ec7831">reserve</a> (int n)
<li>virtual int <a class="el" href="classafg_1_1CrTree.html#a6d6f90d5123fba63aa917af7498a9efa">pack</a> (int ns=0)
<li>int <a class="el" href="classafg_1_1CrTree.html#a9bbe1aa92c4047b57d0eaa3d5fbc562f">get_all_children</a> (int inode, std::set&lt; int &gt; &amp;sch)
</ul>
<tr><td colspan="2"><div class="groupHeader">insertion/deletion</div></td></tr>
<ul>
<li>virtual void <a class="el" href="classafg_1_1CrTree.html#a3a8baa19b17a749942ede7d01f561288">remove_v_byi</a> (int vi)
<li>virtual int <a class="el" href="classafg_1_1CrTree.html#abf5d34c527eceefc527be4601906a278">clean</a> (void)
<li>virtual bool <a class="el" href="classafg_1_1CrTree.html#af75e3888908bf2fc98c2d84e11a1d6e8">insert_e</a> (const <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a> &amp;u, const <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a> &amp;v, const <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a> &amp;e)
<li>virtual bool <a class="el" href="classafg_1_1CrTree.html#ac6100dcbc795d48302ab58bd34e52518">insert_e_byi</a> (int i, int j, const <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a> &amp;e)
<li>virtual void <a class="el" href="classafg_1_1CrTree.html#a44ca25ffb48b5a8fb792385cfcb59adb">remove_e_byi</a> (int nfrom, int nto)
<li><a class="anchor" id="af1f0d0a2ba2ff9d54db24a9262dbe59b"></a><!-- doxytag: member="afg::CrTree::remove_alle_byi" ref="af1f0d0a2ba2ff9d54db24a9262dbe59b" args="(int nfrom)" -->
virtual void <a class="el" href="classafg_1_1CrTree.html#af1f0d0a2ba2ff9d54db24a9262dbe59b">remove_alle_byi</a> (int nfrom)
<dl class="el"><dd class="mdescRight">remove all edges of vertex of index nfrom <br/></dl><li><a class="anchor" id="aefceeeaf7e041387e785ea84d569c069"></a><!-- doxytag: member="afg::CrTree::remove_all_edges" ref="aefceeeaf7e041387e785ea84d569c069" args="(void)" -->
virtual void <a class="el" href="classafg_1_1CrTree.html#aefceeeaf7e041387e785ea84d569c069">remove_all_edges</a> (void)
<dl class="el"><dd class="mdescRight">remove all edges of all vertices <br/></dl><li><a class="anchor" id="aae54ba8b6510a26bb9c1ce9b15adf293"></a><!-- doxytag: member="afg::CrTree::clear" ref="aae54ba8b6510a26bb9c1ce9b15adf293" args="(void)" -->
virtual void <a class="el" href="classafg_1_1CrTree.html#aae54ba8b6510a26bb9c1ce9b15adf293">clear</a> (void)
<dl class="el"><dd class="mdescRight">clear all nodes and all their edges <br/></dl></ul>
<h2><a name="pro-methods"></a>
Protected Member Functions</h2>
<ul>
<li><a class="anchor" id="ad3204172433fd2add613d31aa6890be6"></a><!-- doxytag: member="afg::CrTree::grow" ref="ad3204172433fd2add613d31aa6890be6" args="(int ns=0)" -->
virtual int <b>grow</b> (int ns=0)
</ul>
<h2><a name="pro-attribs"></a>
Protected Attributes</h2>
<ul>
<li><a class="anchor" id="a4e6d90c3d46ce7e9af6c7bd10278fc2a"></a><!-- doxytag: member="afg::CrTree::m_nRoot" ref="a4e6d90c3d46ce7e9af6c7bd10278fc2a" args="" -->
int <b>m_nRoot</b>
<li><a class="anchor" id="ac23fa458b7800a4b13ccaaccaa202581"></a><!-- doxytag: member="afg::CrTree::m_Parents" ref="ac23fa458b7800a4b13ccaaccaa202581" args="" -->
std::vector&lt; int &gt; <b>m_Parents</b>
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class VDT, class EDT, class f_eqv = std::equal_to&lt;VDT&gt;&gt;<br/>
class afg::CrTree&lt; VDT, EDT, f_eqv &gt;</h3>

<p>rooted tree. Tree structure that has a specific root. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abf5d34c527eceefc527be4601906a278"></a><!-- doxytag: member="afg::CrTree::clean" ref="abf5d34c527eceefc527be4601906a278" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VDT , class EDT , class f_eqv  = std::equal_to&lt;VDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classafg_1_1CrTree.html">afg::CrTree</a>&lt; <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a>, <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a>, f_eqv &gt;::clean </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>clean-up the "tree" by removing "isolated" nodes. An "isolated" is a node that is not any node's parent or child; in other words, has no neighbors. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of nodes that are removed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bbe1aa92c4047b57d0eaa3d5fbc562f"></a><!-- doxytag: member="afg::CrTree::get_all_children" ref="a9bbe1aa92c4047b57d0eaa3d5fbc562f" args="(int inode, std::set&lt; int &gt; &amp;sch)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VDT , class EDT , class f_eqv  = std::equal_to&lt;VDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classafg_1_1CrTree.html">afg::CrTree</a>&lt; <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a>, <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a>, f_eqv &gt;::get_all_children </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>get all child nodes of a specific node given by index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>index the specific node </td></tr>
    <tr><td class="paramname">sch</td><td>set to hold indices of the children </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of children found. </dd></dl>

</div>
</div>
<a class="anchor" id="af75e3888908bf2fc98c2d84e11a1d6e8"></a><!-- doxytag: member="afg::CrTree::insert_e" ref="af75e3888908bf2fc98c2d84e11a1d6e8" args="(const VDT &amp;u, const VDT &amp;v, const EDT &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VDT , class EDT , class f_eqv  = std::equal_to&lt;VDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classafg_1_1CrTree.html">afg::CrTree</a>&lt; <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a>, <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a>, f_eqv &gt;::insert_e </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert an edge for vertex u to v. Insertion fails if any of the vertex is not found. If edge already exists then edge data will be replaced by e. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if succeeds, false otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="classafg_1_1CGraph.html#a9f572afa26694483c137c00c5bef9326">afg::CGraph&lt; VDT, EDT, f_eqv &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac6100dcbc795d48302ab58bd34e52518"></a><!-- doxytag: member="afg::CrTree::insert_e_byi" ref="ac6100dcbc795d48302ab58bd34e52518" args="(int i, int j, const EDT &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VDT , class EDT , class f_eqv  = std::equal_to&lt;VDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classafg_1_1CrTree.html">afg::CrTree</a>&lt; <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a>, <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a>, f_eqv &gt;::insert_e_byi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert an edge (i-&gt;j). Insertion fails if any of the two indices is unused (not vertext at that position). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if succeeds, otherwise false. </dd></dl>

<p>Reimplemented from <a class="el" href="classafg_1_1CGraph.html#ab7853d613dfad6dab976b9ab79c9b4a2">afg::CGraph&lt; VDT, EDT, f_eqv &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6d6f90d5123fba63aa917af7498a9efa"></a><!-- doxytag: member="afg::CrTree::pack" ref="a6d6f90d5123fba63aa917af7498a9efa" args="(int ns=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VDT , class EDT , class f_eqv  = std::equal_to&lt;VDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classafg_1_1CrTree.html">afg::CrTree</a>&lt; <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a>, <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a>, f_eqv &gt;::pack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em> = <code>0</code></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rearrange vertices to make them stored consecutively. After <a class="el" href="classafg_1_1CrTree.html#a6d6f90d5123fba63aa917af7498a9efa">pack( )</a>, all iterators and indices may be invalidated. All vertices will be stored within [0, <a class="el" href="classafg_1_1CGraph.html#a7591ac8edd31b089706b4fe9650053db" title="return graph size: number of vertices in the graph">size()</a>-1 ]. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>new range; if ns&lt;<a class="el" href="classafg_1_1CGraph.html#a7591ac8edd31b089706b4fe9650053db" title="return graph size: number of vertices in the graph">size( )</a>, <a class="el" href="classafg_1_1CGraph.html#a7591ac8edd31b089706b4fe9650053db" title="return graph size: number of vertices in the graph">size()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of index changes that have been made. </dd></dl>

<p>Reimplemented from <a class="el" href="classafg_1_1CGraph.html#abfd4df18a29ecbf8b33506652625cdcb">afg::CGraph&lt; VDT, EDT, f_eqv &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1a346395262540eba806787f217f8431"></a><!-- doxytag: member="afg::CrTree::parent_byi" ref="a1a346395262540eba806787f217f8431" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VDT , class EDT , class f_eqv  = std::equal_to&lt;VDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classafg_1_1CrTree.html">afg::CrTree</a>&lt; <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a>, <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a>, f_eqv &gt;::parent_byi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const  throw ( std::out_of_range )<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return parent node of node of index i </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range,with</td><td>message "parent node access in tree". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44ca25ffb48b5a8fb792385cfcb59adb"></a><!-- doxytag: member="afg::CrTree::remove_e_byi" ref="a44ca25ffb48b5a8fb792385cfcb59adb" args="(int nfrom, int nto)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VDT , class EDT , class f_eqv  = std::equal_to&lt;VDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classafg_1_1CrTree.html">afg::CrTree</a>&lt; <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a>, <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a>, f_eqv &gt;::remove_e_byi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove an edge by index. Has no effect if edge not found. </p>

<p>Reimplemented from <a class="el" href="classafg_1_1CGraph.html#af49cd01aec9992be88cec2db2c105888">afg::CGraph&lt; VDT, EDT, f_eqv &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3a8baa19b17a749942ede7d01f561288"></a><!-- doxytag: member="afg::CrTree::remove_v_byi" ref="a3a8baa19b17a749942ede7d01f561288" args="(int vi)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VDT , class EDT , class f_eqv  = std::equal_to&lt;VDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classafg_1_1CrTree.html">afg::CrTree</a>&lt; <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a>, <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a>, f_eqv &gt;::remove_v_byi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vi</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove a vertex of index vi. Has no effect if vertex not found; otherwise this vertex and all related edges (from/to it) will be removed as well. </p>

<p>Reimplemented from <a class="el" href="classafg_1_1CGraph.html#a47284bfb178ee2c9f5a76472332ab28c">afg::CGraph&lt; VDT, EDT, f_eqv &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad615d12d6b0cdc03744470e537ec7831"></a><!-- doxytag: member="afg::CrTree::reserve" ref="ad615d12d6b0cdc03744470e537ec7831" args="(int n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VDT , class EDT , class f_eqv  = std::equal_to&lt;VDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classafg_1_1CrTree.html">afg::CrTree</a>&lt; <a class="el" href="classafg_1_1IGraph.html#ab8703006dd3a7e84fec1eb1bf787eb65">VDT</a>, <a class="el" href="classafg_1_1IGraph.html#adecc188900552ff098a92f50087c8730">EDT</a>, f_eqv &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>reserve a certain size for the tree. Has no effect if n is less than or equal to <a class="el" href="classafg_1_1CGraph.html#aaf2e8d0d15664871da8874b0278a7d81">range( )</a>; otherwise capacity will be increased and all iteroators may be invalidated, but an index should still pointing to the same vertex. </p>

<p>Reimplemented from <a class="el" href="classafg_1_1CGraph.html#a8bd4b158fc7608a758b28ba2eec70449">afg::CGraph&lt; VDT, EDT, f_eqv &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="rtree_8h_source.html">rtree.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceafg.html">afg</a>      </li>
      <li class="navelem"><a class="el" href="classafg_1_1CrTree.html">CrTree</a>      </li>
<center>afgraph - A Framework for Graph Algorithms</center>
