<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>afgraph: afg::CGraph&lt; VertexDT, EdgeDT, f_eqv &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">afgraph</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classafg_1_1CGraph.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">afg::CGraph&lt; VertexDT, EdgeDT, f_eqv &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__mygraph.html">An Implementation of Graph classes</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="afg::CGraph" --><!-- doxytag: inherits="IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;" -->
<p><code>#include &lt;<a class="el" href="graph_8h_source.html">graph.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for afg::CGraph&lt; VertexDT, EdgeDT, f_eqv &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classafg_1_1CGraph__inherit__graph.png" border="0" usemap="#afg_1_1CGraph_3_01VertexDT_00_01EdgeDT_00_01f__eqv_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="afg_1_1CGraph_3_01VertexDT_00_01EdgeDT_00_01f__eqv_01_4_inherit__map" id="afg_1_1CGraph_3_01VertexDT_00_01EdgeDT_00_01f__eqv_01_4_inherit__map">
<area shape="rect" id="node2" href="classafg_1_1IGraph.html" title="afg::IGraph\&lt; VertexDT, EdgeDT, f_eqv, std::vector\&lt; CiVertex\&lt; VertexDT, EdgeDT \&gt; \&gt;::iterator, std::vector\&lt; CiVertex\&lt; VertexDT, EdgeDT \&gt; \&gt;::const_iterator, CiVertex\&lt; VertexDT, EdgeDT \&gt; \&gt;" alt="" coords="5,5,1160,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for afg::CGraph&lt; VertexDT, EdgeDT, f_eqv &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classafg_1_1CGraph__coll__graph.png" border="0" usemap="#afg_1_1CGraph_3_01VertexDT_00_01EdgeDT_00_01f__eqv_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="afg_1_1CGraph_3_01VertexDT_00_01EdgeDT_00_01f__eqv_01_4_coll__map" id="afg_1_1CGraph_3_01VertexDT_00_01EdgeDT_00_01f__eqv_01_4_coll__map">
<area shape="rect" id="node2" href="classafg_1_1IGraph.html" title="afg::IGraph\&lt; VertexDT, EdgeDT, f_eqv, std::vector\&lt; CiVertex\&lt; VertexDT, EdgeDT \&gt; \&gt;::iterator, std::vector\&lt; CiVertex\&lt; VertexDT, EdgeDT \&gt; \&gt;::const_iterator, CiVertex\&lt; VertexDT, EdgeDT \&gt; \&gt;" alt="" coords="315,8,1469,37"/><area shape="rect" id="node6" href="classafl_1_1sorted__list.html" title="afl::sorted_list\&lt; int \&gt;" alt="" coords="821,61,963,91"/><area shape="rect" id="node8" href="classstd_1_1list.html" title="std::list\&lt;int , std::allocator\&lt;int \&gt; \&gt;" alt="" coords="7,61,225,91"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classafg_1_1CGraph-members.html">List of all members.</a></p>
<h2><a name="pub-types"></a>
Public Types</h2>
<tr><td colspan="2"><div class="groupHeader">type definitions.</div></td></tr>
<ul>
<li><a class="anchor" id="a5b294a7c78f9ad9476c962215401f353"></a><!-- doxytag: member="afg::CGraph::EDT" ref="a5b294a7c78f9ad9476c962215401f353" args="" -->
typedef EdgeDT <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a>
<dl class="el"><dd class="mdescRight">edge data type <br/></dl><li><a class="anchor" id="a06a9922b524f913f268335db33a2a6a0"></a><!-- doxytag: member="afg::CGraph::VDT" ref="a06a9922b524f913f268335db33a2a6a0" args="" -->
typedef VertexDT <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a>
<dl class="el"><dd class="mdescRight">vertex data type <br/></dl><li><a class="anchor" id="a39e5b8f48c7e517f4a45599614b14868"></a><!-- doxytag: member="afg::CGraph::iET" ref="a39e5b8f48c7e517f4a45599614b14868" args="" -->
typedef <a class="el" href="classafg_1_1CiEdge.html">CiEdge</a>&lt; EdgeDT &gt; <a class="el" href="classafg_1_1CGraph.html#a39e5b8f48c7e517f4a45599614b14868">iET</a>
<dl class="el"><dd class="mdescRight">edge type <br/></dl><li><a class="anchor" id="a3c521abe6d41582bd0074805c8ed4529"></a><!-- doxytag: member="afg::CGraph::iVT" ref="a3c521abe6d41582bd0074805c8ed4529" args="" -->
typedef <a class="el" href="classafg_1_1CiVertex.html">CiVertex</a>&lt; VertexDT, <br class="typebreak"/>
EdgeDT &gt; <a class="el" href="classafg_1_1CGraph.html#a3c521abe6d41582bd0074805c8ed4529">iVT</a>
<dl class="el"><dd class="mdescRight">vertex type, <br/></dl><li><a class="anchor" id="a1c187e989c3eecec7aaee09be255659f"></a><!-- doxytag: member="afg::CGraph::GT" ref="a1c187e989c3eecec7aaee09be255659f" args="" -->
typedef <a class="el" href="classafg_1_1CGraph.html">CGraph</a>&lt; VertexDT, <br class="typebreak"/>
EdgeDT, f_eqv &gt; <a class="el" href="classafg_1_1CGraph.html#a1c187e989c3eecec7aaee09be255659f">GT</a>
<dl class="el"><dd class="mdescRight">graph type, this class itself <br/></dl><li><a class="anchor" id="a6619dad2492c9220984f44f6f8657bf2"></a><!-- doxytag: member="afg::CGraph::COMPT" ref="a6619dad2492c9220984f44f6f8657bf2" args="" -->
typedef f_eqv <a class="el" href="classafg_1_1CGraph.html#a6619dad2492c9220984f44f6f8657bf2">COMPT</a>
<dl class="el"><dd class="mdescRight">type compare function object to determine if two vertex data are equal <br/></dl><li>typedef std::vector&lt; <a class="el" href="classafg_1_1CiVertex.html">CiVertex</a><br class="typebreak"/>
&lt; VertexDT, EdgeDT &gt;<br class="typebreak"/>
 &gt;::<a class="el" href="classafg_1_1CGraph.html#a1d4cd63f84a8140dbfaec939387d1f45">iterator</a> <a class="el" href="classafg_1_1CGraph.html#a1d4cd63f84a8140dbfaec939387d1f45">iterator</a>
<li>typedef std::vector&lt; <a class="el" href="classafg_1_1CiVertex.html">CiVertex</a><br class="typebreak"/>
&lt; VertexDT, EdgeDT &gt;<br class="typebreak"/>
 &gt;::<a class="el" href="classafg_1_1CGraph.html#ae3623db430bf0304688d0ef699a5f478">const_iterator</a> <a class="el" href="classafg_1_1CGraph.html#ae3623db430bf0304688d0ef699a5f478">const_iterator</a>
<li><a class="anchor" id="a00e1013655c6364aff309bf59fb15584"></a><!-- doxytag: member="afg::CGraph::e_iterator" ref="a00e1013655c6364aff309bf59fb15584" args="" -->
typedef <a class="el" href="classafg_1_1CiVertex.html#a3efc24f32a551f378a99ac01be9c1b44">iVT::iterator</a> <a class="el" href="classafg_1_1CGraph.html#a00e1013655c6364aff309bf59fb15584">e_iterator</a>
<dl class="el"><dd class="mdescRight">edge iterator <br/></dl><li><a class="anchor" id="af47e0a8dd23c450a4a7f66878c0f1897"></a><!-- doxytag: member="afg::CGraph::const_e_iterator" ref="af47e0a8dd23c450a4a7f66878c0f1897" args="" -->
typedef <a class="el" href="classafg_1_1CiVertex.html#a32bbb35a27fdfa4f67f7c5a9cfd424bd">iVT::const_iterator</a> <a class="el" href="classafg_1_1CGraph.html#af47e0a8dd23c450a4a7f66878c0f1897">const_e_iterator</a>
<dl class="el"><dd class="mdescRight">edge iterator, const <br/></dl><li><a class="anchor" id="a16eabf06747e2576d73c6a24e7083ea4"></a><!-- doxytag: member="afg::CGraph::igraph_base_type" ref="a16eabf06747e2576d73c6a24e7083ea4" args="" -->
typedef <a class="el" href="classafg_1_1IGraph.html">IGraph</a>&lt; VertexDT, <br class="typebreak"/>
EdgeDT, f_eqv, typename <br class="typebreak"/>
std::vector&lt; <a class="el" href="classafg_1_1CiVertex.html">CiVertex</a><br class="typebreak"/>
&lt; VertexDT, EdgeDT &gt;<br class="typebreak"/>
 &gt;::<a class="el" href="classafg_1_1CGraph.html#a1d4cd63f84a8140dbfaec939387d1f45">iterator</a>, typename <br class="typebreak"/>
std::vector&lt; <a class="el" href="classafg_1_1CiVertex.html">CiVertex</a><br class="typebreak"/>
&lt; VertexDT, EdgeDT &gt;<br class="typebreak"/>
 &gt;::<a class="el" href="classafg_1_1CGraph.html#ae3623db430bf0304688d0ef699a5f478">const_iterator</a>, <a class="el" href="classafg_1_1CiVertex.html">CiVertex</a><br class="typebreak"/>
&lt; VertexDT, EdgeDT &gt; &gt; <b>igraph_base_type</b>
</ul>
<h2><a name="pub-methods"></a>
Public Member Functions</h2>
<ul>
<li><a class="el" href="classafg_1_1CGraph.html#a2713777821f114435f77e4f56da3671f">CGraph</a> (int size=1, const VertexDT &amp;v=VertexDT(), double dg=0.25, const f_eqv &amp;eqv=f_eqv())
<li><a class="anchor" id="a6075cb6a760b022c6981427194e5194a"></a><!-- doxytag: member="afg::CGraph::CGraph" ref="a6075cb6a760b022c6981427194e5194a" args="(const CGraph&lt; VertexDT, EdgeDT, f_eqv &gt; &amp;rhs)" -->
<b>CGraph</b> (const <a class="el" href="classafg_1_1CGraph.html">CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt; &amp;rhs)
<li><a class="anchor" id="a8b9f04a2a1ac20f929560822e2a9b9ed"></a><!-- doxytag: member="afg::CGraph::operator=" ref="a8b9f04a2a1ac20f929560822e2a9b9ed" args="(const CGraph&lt; VertexDT, EdgeDT, f_eqv &gt; &amp;rhs)" -->
const <a class="el" href="classafg_1_1CGraph.html">CGraph</a>&lt; VertexDT, EdgeDT, <br class="typebreak"/>
f_eqv &gt; &amp; <b>operator=</b> (const <a class="el" href="classafg_1_1CGraph.html">CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt; &amp;rhs)
<li><a class="anchor" id="ac830d4397937feb8c8170fd24ae93926"></a><!-- doxytag: member="afg::CGraph::copy_vertices" ref="ac830d4397937feb8c8170fd24ae93926" args="(const GT &amp;gra)" -->
virtual void <a class="el" href="classafg_1_1CGraph.html#ac830d4397937feb8c8170fd24ae93926">copy_vertices</a> (const <a class="el" href="classafg_1_1CGraph.html">GT</a> &amp;gra)
<dl class="el"><dd class="mdescRight">copy all vertices from a graph <br/></dl><li>virtual void <a class="el" href="classafg_1_1CGraph.html#a8bd4b158fc7608a758b28ba2eec70449">reserve</a> (int n)
<li>virtual int <a class="el" href="classafg_1_1CGraph.html#abfd4df18a29ecbf8b33506652625cdcb">pack</a> (int ns=0)
</ul>
<tr><td colspan="2"><div class="groupHeader">element access and helpers</div></td></tr>
<ul>
<li><a class="anchor" id="ade9af63b055186dc6511a52039dceaba"></a><!-- doxytag: member="afg::CGraph::v_default" ref="ade9af63b055186dc6511a52039dceaba" args="(void) const " -->
const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp; <a class="el" href="classafg_1_1CGraph.html#ade9af63b055186dc6511a52039dceaba">v_default</a> (void) const 
<dl class="el"><dd class="mdescRight">return the default vertex value <br/></dl><li><a class="anchor" id="a483ee1559c56dc0c258e23f3295fe555"></a><!-- doxytag: member="afg::CGraph::begin" ref="a483ee1559c56dc0c258e23f3295fe555" args="(void)" -->
virtual <a class="el" href="classafg_1_1CGraph.html#a1d4cd63f84a8140dbfaec939387d1f45">iterator</a> <a class="el" href="classafg_1_1CGraph.html#a483ee1559c56dc0c258e23f3295fe555">begin</a> (void)
<dl class="el"><dd class="mdescRight">return iterator pointing to the first vertex <br/></dl><li><a class="anchor" id="acf570fcbe371850adab1bdf9f90d199f"></a><!-- doxytag: member="afg::CGraph::end" ref="acf570fcbe371850adab1bdf9f90d199f" args="(void)" -->
virtual <a class="el" href="classafg_1_1CGraph.html#a1d4cd63f84a8140dbfaec939387d1f45">iterator</a> <a class="el" href="classafg_1_1CGraph.html#acf570fcbe371850adab1bdf9f90d199f">end</a> (void)
<dl class="el"><dd class="mdescRight">return iterator pointing to the end (not pointing to any vertex). <br/></dl><li><a class="anchor" id="a1200f0051609569d2add767974931f35"></a><!-- doxytag: member="afg::CGraph::begin" ref="a1200f0051609569d2add767974931f35" args="(void) const " -->
virtual <a class="el" href="classafg_1_1CGraph.html#ae3623db430bf0304688d0ef699a5f478">const_iterator</a> <a class="el" href="classafg_1_1CGraph.html#a1200f0051609569d2add767974931f35">begin</a> (void) const 
<dl class="el"><dd class="mdescRight">return iterator pointing to the first vertex <br/></dl><li><a class="anchor" id="aa663cad062f627eb2a2ed1ebdc7b997a"></a><!-- doxytag: member="afg::CGraph::end" ref="aa663cad062f627eb2a2ed1ebdc7b997a" args="(void) const " -->
virtual <a class="el" href="classafg_1_1CGraph.html#ae3623db430bf0304688d0ef699a5f478">const_iterator</a> <a class="el" href="classafg_1_1CGraph.html#aa663cad062f627eb2a2ed1ebdc7b997a">end</a> (void) const 
<dl class="el"><dd class="mdescRight">return iterator pointing to the end (not pointing to any vertex). <br/></dl><li>virtual <a class="el" href="classafg_1_1CiVertex.html">iVT</a> &amp; <a class="el" href="classafg_1_1CGraph.html#a7e9a704799631a1c36c1e2ad58b263fd">at</a> (int i)
<li>virtual <a class="el" href="classafg_1_1CiVertex.html">iVT</a> &amp; <a class="el" href="classafg_1_1CGraph.html#ad68a03bc7bd44fb02e1769341a417d0d">operator[]</a> (int i)
<li>virtual const <a class="el" href="classafg_1_1CiVertex.html">iVT</a> &amp; <a class="el" href="classafg_1_1CGraph.html#abecc0ae34cc799386a072cf3536bcff3">at</a> (int i) const 
<li>virtual const <a class="el" href="classafg_1_1CiVertex.html">iVT</a> &amp; <a class="el" href="classafg_1_1CGraph.html#ac59ca25c0007453840c8e7aa600715f8">operator[]</a> (int i) const 
<li><a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a> * <a class="el" href="classafg_1_1CGraph.html#a2db505c98bed7523ab6f5d3c392dbc7b">get_edge</a> (const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;u, const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;v)
<li><a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a> * <a class="el" href="classafg_1_1CGraph.html#a22969c5d40341721b04582148d055bea">get_edge_byi</a> (int nfrom, int nto)
<li>const <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a> * <a class="el" href="classafg_1_1CGraph.html#a00e1309983c88762590904724351d4e7">get_edge</a> (const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;u, const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;v) const 
<li>const <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a> * <a class="el" href="classafg_1_1CGraph.html#a8d7e230deb2281ae830904290225f680">get_edge_byi</a> (int nfrom, int nto) const 
<li><a class="anchor" id="a27321f09fbbdf20de036687e8aa23c7d"></a><!-- doxytag: member="afg::CGraph::find_index" ref="a27321f09fbbdf20de036687e8aa23c7d" args="(const VDT &amp;v) const " -->
virtual int <a class="el" href="classafg_1_1CGraph.html#a27321f09fbbdf20de036687e8aa23c7d">find_index</a> (const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;v) const 
<dl class="el"><dd class="mdescRight">find the index of vertex v <br/></dl><li><a class="anchor" id="a7591ac8edd31b089706b4fe9650053db"></a><!-- doxytag: member="afg::CGraph::size" ref="a7591ac8edd31b089706b4fe9650053db" args="(void) const " -->
virtual int <a class="el" href="classafg_1_1CGraph.html#a7591ac8edd31b089706b4fe9650053db">size</a> (void) const 
<dl class="el"><dd class="mdescRight">return graph size: number of vertices in the graph <br/></dl><li>virtual int <a class="el" href="classafg_1_1CGraph.html#aaf2e8d0d15664871da8874b0278a7d81">range</a> (void) const 
<li><a class="anchor" id="a77ef71097d10224113678c1d981c1567"></a><!-- doxytag: member="afg::CGraph::is_in_use" ref="a77ef71097d10224113678c1d981c1567" args="(int i) const " -->
virtual bool <a class="el" href="classafg_1_1CGraph.html#a77ef71097d10224113678c1d981c1567">is_in_use</a> (int i) const 
<dl class="el"><dd class="mdescRight">return if i (range checked) is an index used for a vertex. <br/></dl></ul>
<tr><td colspan="2"><div class="groupHeader">insertion/deletion</div></td></tr>
<ul>
<li>virtual int <a class="el" href="classafg_1_1CGraph.html#abfef29cd60de57f2b2c9b19a5f56ffa8">insert_v_qik</a> (const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;v)
<li>virtual int <a class="el" href="classafg_1_1CGraph.html#ab4993eaaa5a69934ee4c004f4fed3180">insert_v</a> (const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;v)
<li>virtual bool <a class="el" href="classafg_1_1CGraph.html#aceeee570db1a5082a3125c6ed3c45d4a">insert_v_ati</a> (const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;v, int i)
<li>virtual void <a class="el" href="classafg_1_1CGraph.html#a6ba7f7f034c107d1faed8bf2a7b639bb">remove_v</a> (const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;v)
<li>virtual void <a class="el" href="classafg_1_1CGraph.html#a47284bfb178ee2c9f5a76472332ab28c">remove_v_byi</a> (int vi)
<li>virtual bool <a class="el" href="classafg_1_1CGraph.html#a9f572afa26694483c137c00c5bef9326">insert_e</a> (const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;u, const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;v, const <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a> &amp;e)
<li>virtual bool <a class="el" href="classafg_1_1CGraph.html#a2f6228531da91f2b62076bc240d736b0">insert_2e</a> (const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;u, const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;v, const <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a> &amp;e)
<li>virtual bool <a class="el" href="classafg_1_1CGraph.html#ab7853d613dfad6dab976b9ab79c9b4a2">insert_e_byi</a> (int i, int j, const <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a> &amp;e)
<li>virtual bool <a class="el" href="classafg_1_1CGraph.html#a8c091b837acbb8469f8638a2d44610ec">insert_2e_byi</a> (int i, int j, const <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a> &amp;e)
<li>virtual void <a class="el" href="classafg_1_1CGraph.html#a39df29bca11dbe68797b957e305e5baf">remove_e</a> (const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;u, const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;v)
<li>virtual void <a class="el" href="classafg_1_1CGraph.html#ab1fce682e6500c5501a9bd5109fcd370">remove_2e</a> (const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;u, const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;v)
<li>virtual void <a class="el" href="classafg_1_1CGraph.html#abcdb0cb7e6dbbe828a0018160134acdc">remove_alle</a> (const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;u)
<li>virtual void <a class="el" href="classafg_1_1CGraph.html#af49cd01aec9992be88cec2db2c105888">remove_e_byi</a> (int nfrom, int nto)
<li>virtual void <a class="el" href="classafg_1_1CGraph.html#a5dce2ac4fb26017730b4246f3446d2e0">remove_2e_byi</a> (int n1, int n2)
<li><a class="anchor" id="a54972962facb3d3dd312344632f755e7"></a><!-- doxytag: member="afg::CGraph::remove_alle_byi" ref="a54972962facb3d3dd312344632f755e7" args="(int nfrom)" -->
virtual void <a class="el" href="classafg_1_1CGraph.html#a54972962facb3d3dd312344632f755e7">remove_alle_byi</a> (int nfrom)
<dl class="el"><dd class="mdescRight">remove all edges of vertex of index nfrom <br/></dl><li><a class="anchor" id="afb08f3d4131eb364d9d2ea4509d4ffb0"></a><!-- doxytag: member="afg::CGraph::remove_all_edges" ref="afb08f3d4131eb364d9d2ea4509d4ffb0" args="(void)" -->
virtual void <a class="el" href="classafg_1_1CGraph.html#afb08f3d4131eb364d9d2ea4509d4ffb0">remove_all_edges</a> (void)
<dl class="el"><dd class="mdescRight">remove all edges of all vertices <br/></dl><li><a class="anchor" id="a465671567c1dc0eb2f4715bb58b46875"></a><!-- doxytag: member="afg::CGraph::clear" ref="a465671567c1dc0eb2f4715bb58b46875" args="(void)" -->
virtual void <a class="el" href="classafg_1_1CGraph.html#a465671567c1dc0eb2f4715bb58b46875">clear</a> (void)
<dl class="el"><dd class="mdescRight">clear all nodes and all their edges <br/></dl></ul>
<h2><a name="pro-methods"></a>
Protected Member Functions</h2>
<ul>
<li><a class="anchor" id="a0481e7598dbe4f9de519f9964d9598e3"></a><!-- doxytag: member="afg::CGraph::grow" ref="a0481e7598dbe4f9de519f9964d9598e3" args="(int ns=0)" -->
virtual int <b>grow</b> (int ns=0)
</ul>
<h2><a name="pro-attribs"></a>
Protected Attributes</h2>
<tr><td colspan="2"><div class="groupHeader">data members</div></td></tr>
<ul>
<li><a class="anchor" id="ae42056ea169aebd4d872f75daa0f3acd"></a><!-- doxytag: member="afg::CGraph::m_Vertices" ref="ae42056ea169aebd4d872f75daa0f3acd" args="" -->
std::vector&lt; <a class="el" href="classafg_1_1CiVertex.html">CiVertex</a><br class="typebreak"/>
&lt; VertexDT, EdgeDT &gt; &gt; <a class="el" href="classafg_1_1CGraph.html#ae42056ea169aebd4d872f75daa0f3acd">m_Vertices</a>
<dl class="el"><dd class="mdescRight">data member, vertices <br/></dl><li><a class="anchor" id="a1bfd39e1dec114a9b466ba9a4db902b1"></a><!-- doxytag: member="afg::CGraph::m_vDefault" ref="a1bfd39e1dec114a9b466ba9a4db902b1" args="" -->
VertexDT <a class="el" href="classafg_1_1CGraph.html#a1bfd39e1dec114a9b466ba9a4db902b1">m_vDefault</a>
<dl class="el"><dd class="mdescRight">default vertex value <br/></dl><li><a class="anchor" id="a20f7ab3a023d91f056b83fcf68ebd64c"></a><!-- doxytag: member="afg::CGraph::m_nSize" ref="a20f7ab3a023d91f056b83fcf68ebd64c" args="" -->
int <a class="el" href="classafg_1_1CGraph.html#a20f7ab3a023d91f056b83fcf68ebd64c">m_nSize</a>
<dl class="el"><dd class="mdescRight">size of the graph, which is the number of vertices <br/></dl><li><a class="anchor" id="a1f3dc0e6574de35ea450ff4fb41db900"></a><!-- doxytag: member="afg::CGraph::m_dGrow" ref="a1f3dc0e6574de35ea450ff4fb41db900" args="" -->
double <a class="el" href="classafg_1_1CGraph.html#a1f3dc0e6574de35ea450ff4fb41db900">m_dGrow</a>
<dl class="el"><dd class="mdescRight">growth percentage when vertex vector is full <br/></dl><li><a class="anchor" id="aee4a34667ef55133e1c666142a618b23"></a><!-- doxytag: member="afg::CGraph::m_iUnused" ref="aee4a34667ef55133e1c666142a618b23" args="" -->
<a class="el" href="classafl_1_1sorted__list.html">afl::sorted_list</a>&lt; int &gt; <a class="el" href="classafg_1_1CGraph.html#aee4a34667ef55133e1c666142a618b23">m_iUnused</a>
<dl class="el"><dd class="mdescRight">list of unused indices in m_Vertices <br/></dl></ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt;<br/>
class afg::CGraph&lt; VertexDT, EdgeDT, f_eqv &gt;</h3>

<p>The graph class. A graph is represented as an adjacency list, naturally a directed graph. To store an un-directed graph, each edge will be kept as two copies. A vertex has "vertex data" of type VertexDT, which could be simple type (e.g., int, string) or a compound type (e.g., including x,y coordinates). An edge has "edge data" of type EdgeDT, which could be "simple" data type (int, double representing weight), or compound (two double number, or a weight plust a string as a "label"). See <a class="el" href="edge_8h.html">edge.h</a></p>
<p>In many comments, the words of vertex and node are used interchangeablly.</p>
<p>Internally vertices (adjacency list) are stored in a vector, for fast access. Many algorithms will use [ index ] to access vertices (with their edges) by index.</p>
<p>VertexDT: data type of vertex data, must have default constructor defined; a default value of VertexDT type must be provided for the constructor, which should be some value a "normal" vertex never has. EdgeDT: data type of edge data. f_eqv: a function object which compares two vertex data to see they are equal; by default, std::equal_to is used.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Aiguo Fei </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.5a, November/December 2000 </dd></dl>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ae3623db430bf0304688d0ef699a5f478"></a><!-- doxytag: member="afg::CGraph::const_iterator" ref="ae3623db430bf0304688d0ef699a5f478" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classafg_1_1CiVertex.html">CiVertex</a>&lt;VertexDT, EdgeDT&gt; &gt;::<a class="el" href="classafg_1_1CGraph.html#ae3623db430bf0304688d0ef699a5f478">const_iterator</a> <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::<a class="el" href="classafg_1_1CGraph.html#ae3623db430bf0304688d0ef699a5f478">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>iterator type to access vertices. Only read access is allowed. </p>

<p>Reimplemented from <a class="el" href="classafg_1_1IGraph.html#a217530d8b84e2bfda16e4bf747066863">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1d4cd63f84a8140dbfaec939387d1f45"></a><!-- doxytag: member="afg::CGraph::iterator" ref="a1d4cd63f84a8140dbfaec939387d1f45" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classafg_1_1CiVertex.html">CiVertex</a>&lt;VertexDT, EdgeDT&gt; &gt;::<a class="el" href="classafg_1_1CGraph.html#a1d4cd63f84a8140dbfaec939387d1f45">iterator</a> <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::<a class="el" href="classafg_1_1CGraph.html#a1d4cd63f84a8140dbfaec939387d1f45">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>iterator type to access vertices. </p>

<p>Reimplemented from <a class="el" href="classafg_1_1IGraph.html#a2e42f92c9d6d94250fd65b43a86974e3">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2713777821f114435f77e4f56da3671f"></a><!-- doxytag: member="afg::CGraph::CGraph" ref="a2713777821f114435f77e4f56da3671f" args="(int size=1, const VertexDT &amp;v=VertexDT(), double dg=0.25, const f_eqv &amp;eqv=f_eqv())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::<a class="el" href="classafg_1_1CGraph.html">CGraph</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexDT &amp;&#160;</td>
          <td class="paramname"><em>v</em> = <code>VertexDT()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dg</em> = <code>0.25</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const f_eqv &amp;&#160;</td>
          <td class="paramname"><em>eqv</em> = <code>f_eqv()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>constructor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vertex data value that won't be taken by any vertex, internally used by <a class="el" href="classafg_1_1CGraph.html">CGraph</a> to fill unused vertex table entries. </td></tr>
    <tr><td class="paramname">dg</td><td>growth percentage to grow a graph when graph needs to grow due to insertion of new vertices. </td></tr>
    <tr><td class="paramname">eqv</td><td>predicate to determine if two vertices are equivalent (having the same key or id); default std::equal_to is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7e9a704799631a1c36c1e2ad58b263fd"></a><!-- doxytag: member="afg::CGraph::at" ref="a7e9a704799631a1c36c1e2ad58b263fd" args="(int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classafg_1_1CiVertex.html">iVT</a>&amp; <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return vertex at position i </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range.</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#af7030acc3e6b9fe86c5ef3606f60bee2">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abecc0ae34cc799386a072cf3536bcff3"></a><!-- doxytag: member="afg::CGraph::at" ref="abecc0ae34cc799386a072cf3536bcff3" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classafg_1_1CiVertex.html">iVT</a>&amp; <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return vertex at position i, const version. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range.</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a66ea4ebb7405fc70eab0f8d6854cc248">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2db505c98bed7523ab6f5d3c392dbc7b"></a><!-- doxytag: member="afg::CGraph::get_edge" ref="a2db505c98bed7523ab6f5d3c392dbc7b" args="(const VDT &amp;u, const VDT &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a>* <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::get_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get edge data (from u to v). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to that edge (data), NULL if not found. </dd></dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#af474cbdb00fed77ae44cdcd11635f324">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a00e1309983c88762590904724351d4e7"></a><!-- doxytag: member="afg::CGraph::get_edge" ref="a00e1309983c88762590904724351d4e7" args="(const VDT &amp;u, const VDT &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a>* <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::get_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get edge data (from u to v), const version. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to that edge (data), NULL if not found. </dd></dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a3cd83fe8c1bb4b53fe48e50a8125ab3d">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a22969c5d40341721b04582148d055bea"></a><!-- doxytag: member="afg::CGraph::get_edge_byi" ref="a22969c5d40341721b04582148d055bea" args="(int nfrom, int nto)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a>* <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::get_edge_byi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>get edge data by index. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to that edge (data), NULL if not found. </dd></dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a1fa758153907039dbff75bc449847402">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8d7e230deb2281ae830904290225f680"></a><!-- doxytag: member="afg::CGraph::get_edge_byi" ref="a8d7e230deb2281ae830904290225f680" args="(int nfrom, int nto) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a>* <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::get_edge_byi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>get edge data by index. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to that edge (data), NULL if not found. </dd></dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a276f019ef8011beca88d155b264f189a">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2f6228531da91f2b62076bc240d736b0"></a><!-- doxytag: member="afg::CGraph::insert_2e" ref="a2f6228531da91f2b62076bc240d736b0" args="(const VDT &amp;u, const VDT &amp;v, const EDT &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::insert_2e </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert both (u-&gt;v) and (v-&gt;u). The same edge data is used for both edges. Equivalent to "insert_e(u,v,e); insert_e(v,u,e);". </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classafg_1_1CGraph.html#a9f572afa26694483c137c00c5bef9326">insert_e( )</a> </dd></dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#ae7c647af2de1b9f57cef838b05986c72">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8c091b837acbb8469f8638a2d44610ec"></a><!-- doxytag: member="afg::CGraph::insert_2e_byi" ref="a8c091b837acbb8469f8638a2d44610ec" args="(int i, int j, const EDT &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::insert_2e_byi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert both (i-&gt;j) and (j-&gt;i). The same edge data is used for both edges. Equivalent to "insert_e(i,j,e); insert_e(j,i,e);". </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classafg_1_1CGraph.html#ab7853d613dfad6dab976b9ab79c9b4a2">insert_e_byi( )</a> </dd></dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#ab10726db9a27435691986b5c7e4bb4d0">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9f572afa26694483c137c00c5bef9326"></a><!-- doxytag: member="afg::CGraph::insert_e" ref="a9f572afa26694483c137c00c5bef9326" args="(const VDT &amp;u, const VDT &amp;v, const EDT &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::insert_e </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert an edge for vertex u to v. Insertion fails if any of the vertex is not found. If edge already exists then edge data will be replaced by e. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if succeeds, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a5969359d5691f1f6d598cbe67f3bb013">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classafg_1_1CrTree.html#af75e3888908bf2fc98c2d84e11a1d6e8">afg::CrTree&lt; VDT, EDT, f_eqv &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab7853d613dfad6dab976b9ab79c9b4a2"></a><!-- doxytag: member="afg::CGraph::insert_e_byi" ref="ab7853d613dfad6dab976b9ab79c9b4a2" args="(int i, int j, const EDT &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::insert_e_byi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a5b294a7c78f9ad9476c962215401f353">EDT</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert an edge (i-&gt;j). Insertion fails if any of the two indices is unused (not vertext at that position). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if succeeds, otherwise false. </dd></dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a1f6b138548a0fb0feec3f5643b495cbb">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classafg_1_1CrTree.html#ac6100dcbc795d48302ab58bd34e52518">afg::CrTree&lt; VDT, EDT, f_eqv &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab4993eaaa5a69934ee4c004f4fed3180"></a><!-- doxytag: member="afg::CGraph::insert_v" ref="ab4993eaaa5a69934ee4c004f4fed3180" args="(const VDT &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::insert_v </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert a vertex of value v. Vertex data is updated if vertex (v) already exists. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>index of the vertex in vertex table, -1 (an invalid index) to indicate failure. </dd></dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a20efa4902c1a04e39207c06011e27c3b">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aceeee570db1a5082a3125c6ed3c45d4a"></a><!-- doxytag: member="afg::CGraph::insert_v_ati" ref="aceeee570db1a5082a3125c6ed3c45d4a" args="(const VDT &amp;v, int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::insert_v_ati </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert a vertex of value v at position i. This allows a graph user to control vertex of each position. Existing vertex at position i (if exist) will be replaced by v, any existing edge will be lost. However, any other edge pointing to this vertex will still be there. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if insertion succeeds; false if fails (table is smaller than i and fails to grow). </dd></dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a1aff505b2c5b62803607fb9dfee2ccdd">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abfef29cd60de57f2b2c9b19a5f56ffa8"></a><!-- doxytag: member="afg::CGraph::insert_v_qik" ref="abfef29cd60de57f2b2c9b19a5f56ffa8" args="(const VDT &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::insert_v_qik </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert a vertex of value v. Quick version that doesn't search for existing vertex of the same value -- use this if it is known that the new vertex doesn't exist. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>index of the vertex in vertex table, -1 (an invalid index) to indicate failure. </dd></dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a46385570dd544e2a23775bc56e6c18dc">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad68a03bc7bd44fb02e1769341a417d0d"></a><!-- doxytag: member="afg::CGraph::operator[]" ref="ad68a03bc7bd44fb02e1769341a417d0d" args="(int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classafg_1_1CiVertex.html">iVT</a>&amp; <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return vertex at position i </p>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#af292b009d4ff43116663993163c3e844">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac59ca25c0007453840c8e7aa600715f8"></a><!-- doxytag: member="afg::CGraph::operator[]" ref="ac59ca25c0007453840c8e7aa600715f8" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classafg_1_1CiVertex.html">iVT</a>&amp; <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return vertex at position i, const version. </p>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#ae8dc90a4ac43772eb676a74987c91559">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abfd4df18a29ecbf8b33506652625cdcb"></a><!-- doxytag: member="afg::CGraph::pack" ref="abfd4df18a29ecbf8b33506652625cdcb" args="(int ns=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::pack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em> = <code>0</code></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rearrange vertices to make them stored consecutively. After <a class="el" href="classafg_1_1CGraph.html#abfd4df18a29ecbf8b33506652625cdcb">pack( )</a>, all iterators and indices may be invalidated. All vertices will be stored within [0, <a class="el" href="classafg_1_1CGraph.html#a7591ac8edd31b089706b4fe9650053db" title="return graph size: number of vertices in the graph">size()</a>-1 ]. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>new capacity; if ns&lt;<a class="el" href="classafg_1_1CGraph.html#a7591ac8edd31b089706b4fe9650053db" title="return graph size: number of vertices in the graph">size( )</a>, <a class="el" href="classafg_1_1CGraph.html#a7591ac8edd31b089706b4fe9650053db" title="return graph size: number of vertices in the graph">size()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of index changes that have been made. </dd></dl>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a77bc4eec2f052bb8c1917b744017525c">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classafg_1_1CrTree.html#a6d6f90d5123fba63aa917af7498a9efa">afg::CrTree&lt; VDT, EDT, f_eqv &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aaf2e8d0d15664871da8874b0278a7d81"></a><!-- doxytag: member="afg::CGraph::range" ref="aaf2e8d0d15664871da8874b0278a7d81" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::range </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return current upper bound on vertex index range. Vertex index will be within [0, <a class="el" href="classafg_1_1CGraph.html#aaf2e8d0d15664871da8874b0278a7d81">range()</a>-1 ], will always have <a class="el" href="classafg_1_1CGraph.html#aaf2e8d0d15664871da8874b0278a7d81">range()</a>&gt;=size() </p>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a01a18b1ad99c754b095d0f4ff932092e">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab1fce682e6500c5501a9bd5109fcd370"></a><!-- doxytag: member="afg::CGraph::remove_2e" ref="ab1fce682e6500c5501a9bd5109fcd370" args="(const VDT &amp;u, const VDT &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::remove_2e </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove both (u-&gt;v) and (v-&gt;u). Equivalent to "remove_e(u,v); remove_e(v,u);". Has no effect if edge not found. </p>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a5885d57eaf29dc33160d9bff0c9b9e90">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5dce2ac4fb26017730b4246f3446d2e0"></a><!-- doxytag: member="afg::CGraph::remove_2e_byi" ref="a5dce2ac4fb26017730b4246f3446d2e0" args="(int n1, int n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::remove_2e_byi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove both edges by index. Has no effect if edge not found. </p>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a3d7264541219cd0e152133c840432391">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abcdb0cb7e6dbbe828a0018160134acdc"></a><!-- doxytag: member="afg::CGraph::remove_alle" ref="abcdb0cb7e6dbbe828a0018160134acdc" args="(const VDT &amp;u)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::remove_alle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove all edges of vertex v. Has no effect if vertex not found. </p>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#afec7e78040c5a1d8dc4635cec27f4148">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a39df29bca11dbe68797b957e305e5baf"></a><!-- doxytag: member="afg::CGraph::remove_e" ref="a39df29bca11dbe68797b957e305e5baf" args="(const VDT &amp;u, const VDT &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::remove_e </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove edge (u-&gt;v). Has no effect if edge not found. </p>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a968e07dea017ebe8037775226ce7256c">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af49cd01aec9992be88cec2db2c105888"></a><!-- doxytag: member="afg::CGraph::remove_e_byi" ref="af49cd01aec9992be88cec2db2c105888" args="(int nfrom, int nto)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::remove_e_byi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove an edge by index. Has no effect if edge not found. </p>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a1238e61cc820b429f3e438adf7699992">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classafg_1_1CrTree.html#a44ca25ffb48b5a8fb792385cfcb59adb">afg::CrTree&lt; VDT, EDT, f_eqv &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6ba7f7f034c107d1faed8bf2a7b639bb"></a><!-- doxytag: member="afg::CGraph::remove_v" ref="a6ba7f7f034c107d1faed8bf2a7b639bb" args="(const VDT &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::remove_v </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafg_1_1CGraph.html#a06a9922b524f913f268335db33a2a6a0">VDT</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove a vertex of value v. Has no effect if vertex not found; otherwise this vertex and all related edges (from/to it) will be removed as well. </p>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a427a696191a45ee5299e4ea4e658b15e">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a47284bfb178ee2c9f5a76472332ab28c"></a><!-- doxytag: member="afg::CGraph::remove_v_byi" ref="a47284bfb178ee2c9f5a76472332ab28c" args="(int vi)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::remove_v_byi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vi</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove a vertex of index vi. Has no effect if vertex not found; otherwise this vertex and all related edges (from/to it) will be removed as well. </p>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a542621e7d737fa76830ed194375bf82e">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classafg_1_1CrTree.html#a3a8baa19b17a749942ede7d01f561288">afg::CrTree&lt; VDT, EDT, f_eqv &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8bd4b158fc7608a758b28ba2eec70449"></a><!-- doxytag: member="afg::CGraph::reserve" ref="a8bd4b158fc7608a758b28ba2eec70449" args="(int n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VertexDT, class EdgeDT, class f_eqv = std::equal_to&lt;VertexDT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classafg_1_1CGraph.html">afg::CGraph</a>&lt; VertexDT, EdgeDT, f_eqv &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>reserve a certain size for the graph. Has no effect if n is less than or equal to <a class="el" href="classafg_1_1CGraph.html#aaf2e8d0d15664871da8874b0278a7d81">range( )</a>; otherwise capacity will be increased and all iteroators may be invalidated, but an index should still pointing to the same vertex. </p>

<p>Implements <a class="el" href="classafg_1_1IGraph.html#a032af240e13399fed085bfa60cc5fd4e">afg::IGraph&lt; VertexDT, EdgeDT, f_eqv, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::iterator, std::vector&lt; CiVertex&lt; VertexDT, EdgeDT &gt; &gt;::const_iterator, CiVertex&lt; VertexDT, EdgeDT &gt; &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classafg_1_1CrTree.html#ad615d12d6b0cdc03744470e537ec7831">afg::CrTree&lt; VDT, EDT, f_eqv &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="graph_8h_source.html">graph.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceafg.html">afg</a>      </li>
      <li class="navelem"><a class="el" href="classafg_1_1CGraph.html">CGraph</a>      </li>
<center>afgraph - A Framework for Graph Algorithms</center>
